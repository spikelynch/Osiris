<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>../Osiris/lib/Osiris.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#variables">VARIABLES</a></li>
	<li><a href="#hooks">HOOKS</a></li>
	<li><a href="#routes">ROUTES</a></li>
	<ul>

		<li><a href="#authentication">Authentication</a></li>
		<li><a href="#jobs">Jobs</a></li>
		<li><a href="#browsing_and_searching">Browsing and Searching</a></li>
		<li><a href="#starting_and_viewing_jobs">Starting and viewing jobs</a></li>
	</ul>

	<li><a href="#methods">METHODS</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Osiris</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Dancer interface to the Isis planetary imaging toolkit</p>
<p>
</p>
<hr />
<h1><a name="variables">VARIABLES</a></h1>
<dl>
<dt><strong><a name="_version" class="item">$VERSION - release name and number</a></strong></dt>

<dt><strong><a name="_toc" class="item">$toc - Isis table of contents - hash by command name</a></strong></dt>

<dt><strong><a name="_cats" class="item">$cats - Isis apps as a hash by category</a></strong></dt>

<dt><strong><a name="_extra_form" class="item">$extra_form - optional extra form for the job page</a></strong></dt>

<dt><strong><a name="_extra_fields" class="item">$extra_fields - list of field names for the extra form</a></strong></dt>

<dt><strong><a name="_user" class="item">$user - Osiris::User if there's a current user session</a></strong></dt>

<dt><strong><a name="_jobshash" class="item">$jobshash - user's jobs as a hashref by job ID</a></strong></dt>

<dt><strong><a name="_jobs" class="item">$jobs - user's jobs as an arrayref</a></strong></dt>

</dl>
<p>
</p>
<hr />
<h1><a name="hooks">HOOKS</a></h1>
<dl>
<dt><strong><a name="before" class="item">before</a></strong></dt>

<dd>
<p>The 'before' hook checks if there is a user session active.  If there
isn't, it tests to see if this request is part of the authentication process.
If it's not, it redirects the user to either the AAF login URL, or, if
we are running in 'fake_AAF' mode, to the fake AAF login page.</p>
<p>To make things simpler, a route is part of the authentication process iff
it starts with '/auth'.</p>
<p>If there is a session and user, we set up the $user, $jobs and $jobshash
global variables, as they are used in every other page.</p>
<p>If the user can't be created, destroy the session and go back to the login page</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="routes">ROUTES</a></h1>
<p>Dancer routes, defined by a method ('get', 'post' or 'ajax') and a path.</p>
<p>
</p>
<h2><a name="authentication">Authentication</a></h2>
<dl>
<dt><strong><a name="get_auth_login" class="item">get /auth/login</a></strong></dt>

<dd>
<p>Authentication page. If the config variable 'aafmode' is set to 'test',
will automatically authenticate with a fake account.</p>
<p>Template: login.tt</p>
</dd>
<dt><strong><a name="post_auth_aaf" class="item">post /auth/aaf</a></strong></dt>

<dd>
<p>The endpoint for AAF RapidConnect authentication.</p>
<p>Adapted from <a href="https://gist.github.com/bradleybeddoes/6154072">https://gist.github.com/bradleybeddoes/6154072</a></p>
<p>See <a href="https://rapid.aaf.edu.au/developers">https://rapid.aaf.edu.au/developers</a> for full details.</p>
<p>This is the callback endpoint: after users authenticate via AAF, an
encrypted JSON web token is POSTed to this URL.</p>
<p>The 'is_fake' param is used to test this with a fake JSON we generated
ourselves.</p>
</dd>
<dt><strong><a name="get_auth_fakeaff" class="item">get /auth/fakeaff</a></strong></dt>

<dd>
<p>This is a URL for preliminary testing of AAF, before we send our
endpoint for registration.  It encodes a JWT from the config values,
which will definitely match when it gets to the auth endpoint.</p>
</dd>
<dt><strong><a name="get_auth_showaff" class="item">get /auth/showaff</a></strong></dt>

<dd>
<p>Show the fake AAF details.</p>
</dd>
<dt><strong><a name="get_auth_logout" class="item">get /auth/logout</a></strong></dt>

<dd>
<p>Destroy the current session and redirect to the login page</p>
</dd>
</dl>
<p>
</p>
<h2><a name="jobs">Jobs</a></h2>
<dl>
<dt><strong><a name="get" class="item">get /</a></strong></dt>

<dd>
<p>The home page.  Shows a list of the user's jobs, or a 'getting started'
message if they have not yet created any.</p>
</dd>
<dt><strong><a name="get_job_id" class="item">get job/$id</a></strong></dt>

<dd>
<p>Display details of job $id</p>
</dd>
<dt><strong><a name="get_job_id_files_file" class="item">get job/$id/files/$file</a></strong></dt>

<dd>
<p>Passes through the specified file from a job.  Note: this should probably
be implemented differently, as pushing big files through Dancer isn't the
best way to do this.</p>
</dd>
<dt><strong><a name="get_files" class="item">get /files</a></strong></dt>

<dd>
<p>Returns a list of files</p>
</dd>
<dt><strong><a name="ajax_jobs_ext" class="item">ajax /jobs/:ext</a></strong></dt>

<dd>
<p>Ajax handler which returns a list of all files matching an extension
pattern, as a JSON data structure like:</p>
<pre>
    { jobid =&gt; { inputs =&gt; [ files, ... ], outputs =&gt; [ files, ... ] } }</pre>
<p>The extensions should be passed in as a list delimited by semicolons,
for eg 'cub;qub' matches *.cub and *.qub files (with case folding)</p>
</dd>
<dt><strong><a name="ajax_files_id" class="item">ajax /files/:id</a></strong></dt>

<dd>
<p>Returns a JSON object with all the files for a given job</p>
</dd>
</dl>
<p>
</p>
<h2><a name="browsing_and_searching">Browsing and Searching</a></h2>
<dl>
<dt><strong><a name="get_browse_by" class="item">get /browse/:by</a></strong></dt>

<dd>
<p>Top-level browsing route.  'by' can either be 'category' or 'mission'.</p>
<p>Displays a page with all the categories or missions.</p>
</dd>
<dt><strong><a name="get_browse_by_class" class="item">get /browse/:by/:class</a></strong></dt>

<dd>
<p>List all the programs in a specific category or mission</p>
</dd>
<dt><strong><a name="get_search_q_query" class="item">get /search?q=$query</a></strong></dt>

<dd>
<p>Search for an app (in app names and descriptions) and return a list.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="starting_and_viewing_jobs">Starting and viewing jobs</a></h2>
<dl>
<dt><strong><a name="get_app_app" class="item">get /app/:app</a></strong></dt>

<dd>
<p>Displays the web form for the app.</p>
</dd>
<dt><strong><a name="post_app" class="item">/post/:app</a></strong></dt>

<dd>
<p>Starts a job: takes the parameters posted and creates a job file with them</p>
</dd>
<dt><strong><a name="post_job_id" class="item">post /job/:id</a></strong></dt>

<dd>
<p>Accept the extra form fields and write them into the job file.  This
is how the system accepts publication metadata.</p>
<p>The contents of the extra form fields is controlled by
views/metadata_form.xml, which is in the same format as the Isis
application XML files.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="input_files" class="item"><code>input_files(%params)</code></a></strong></dt>

<dd>
<p>This method takes the parameters submitted when creating a job and processes
each of the input file parameters.</p>
<dl>
<dt><strong><a name="job" class="item">job</a></strong></dt>

<dt><strong><a name="app" class="item">app</a></strong></dt>

<dt><strong><a name="user" class="item">user</a></strong></dt>

<dt><strong><a name="params" class="item">params</a></strong></dt>

</dl>
<p>If the user has submitted a file to upload, it copies it into the working
directory for the job.</p>
<p>Otherwise, if they have selected a file from a previous job, it builds a
path to that file.</p>
<p>If neither of these works, logs an error and returns the error template.</p>
</dd>
<dt><strong><a name="get_app" class="item">get_app(name =&gt; $name);</a></strong></dt>

<dd>
<p>Looks up the table of contents by app name and returns an Osiris::App
object</p>
</dd>
<dt><strong><a name="load_toc" class="item">load_toc(isisdir =&gt; $id, isistoc =&gt; $it)</a></strong></dt>

<dd>
<p>Loads and parses the applicationTOC.xml file, builds the table of contents.</p>
</dd>
<dt><strong><a name="search_toc" class="item">search_toc(search =&gt; $search);</a></strong></dt>

<dd>
<p>Search the table of contents.  Returns a list of results as</p>
<pre>

  { app =&gt; $app, description =&gt; $desc }</pre>
<p>hashes in alphabetical order.</p>
</dd>
<dt><strong><a name="load_extras" class="item"><code>load_extras($xml)</code></a></strong></dt>

<dd>
<p>load the 'extras' form, which we're using to collect metadata to push
out to the RDC</p>
</dd>
<dt><strong><a name="kludge_uri_for" class="item"><code>kludge_uri_for($path)</code></a></strong></dt>

<dd>
<p>Hack to get around a bug in the deployment layer which was defaulting
the protocol to http:// when we want it to be https://</p>
<p>If the config variable 'forceprotocol', it forces it.</p>
</dd>
<dt><strong><a name="browser_files" class="item"><code>browser_files($exts)</code></a></strong></dt>

<dd>
<p>Backend for the ajax jobs/ method.  $exts is a semicolon-delimited set
of extensions.  If $exts is empty, returns all input and output files</p>
</dd>
</dl>

</body>

</html>
