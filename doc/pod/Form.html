<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>../Osiris/lib/Osiris/Form.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#api">API</a></li>
	<li><a href="#methods">METHODS</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Osiris::Form</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    my $form = Osiris::Form-&gt;new(
        xml =&gt; $xml_file
    ) || do {
        $log-&gt;error(&quot;Init form failed&quot;);
        return undef;
    };</pre>
<pre>
    $form-&gt;parse || do {
        $log-&gt;error(&quot;Form parse failed&quot;);
        return undef;
    };</pre>
<pre>
    my $groups = $form-&gt;groups;
    my $guards = $form-&gt;guards;</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Class for parsing ISIS forms - used both on the App and Job pages.</p>
<p>
</p>
<hr />
<h1><a name="api">API</a></h1>
<p>Here is how the Isis application XML for a program is represented as
a Perl data structure in an Osiris::Form object:</p>
<pre>
    form = ARRAYREF of groups:
        { 
            name =&gt; GROUPNAME
            parameters =&gt; ARRAYREF of parameters:
                [
                    {
                        name        =&gt; NAME
                        field_type  =&gt; FIELD_TYPE
                        type        =&gt; DATA_TYPE
                        description =&gt; DESCRIPTION
                        default     =&gt; DEFAULT
                        ... (more) ...
                    },                  
                    ...
                ]
        }
        ...</pre>
<p>FIELD_TYPE is one of text_field
                     textarea_field
                     list_field
                     boolean_field
                     input_file_field 
                     output_file_field</p>
<p>TYPE is one of string/integer/double/boolean</p>
<p>Note that textarea_fields are not in the Isis XML but I've added them
to support textareas in the additional metadata fields.</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="new" class="item">new(xml =&gt; $xml)</a></strong></dt>

<dd>
<p>Create an Osiris::Form.  If the xml file is missing, returns undef.</p>
</dd>
<dt><strong><a name="description" class="item"><code>description()</code></a></strong></dt>

<dd>
<p>Returns the program description</p>
</dd>
<dt><strong><a name="groups" class="item"><code>groups()</code></a></strong></dt>

<dd>
<p>Returns an arrayref of parameter groups.  This is the way the Dancer
code gets the form definition which is rendered in the form.tt view.</p>
</dd>
<dt><strong><a name="params" class="item"><code>params()</code></a></strong></dt>

<dd>
<p>Returns an array of the names of all of the form parameters.</p>
</dd>
<dt><strong><a name="input_params" class="item"><code>input_params()</code></a></strong></dt>

<dd>
<p>Returns an array of the names of all of the file input parameters.</p>
</dd>
<dt><strong><a name="output_params" class="item"><code>output_params()</code></a></strong></dt>

<dd>
<p>Returns an array of the names of all of the file output parameters.</p>
</dd>
<dt><strong><a name="_aref" class="item"><code>_aref()</code></a></strong></dt>

<dd>
<p>Utility method to de-reference arrayrefs and return arrays.</p>
</dd>
<dt><strong><a name="param" class="item">param(param =&gt; $paramnane)</a></strong></dt>

<dd>
<p>Return a parameter as a data structure (see API above)</p>
</dd>
<dt><strong><a name="guards" class="item"><code>guards()</code></a></strong></dt>

<dd>
<p>Returns the form's guards as a hashref.  The guards are a set of value
constraints on each parameter, as follows</p>
<dl>
<dt><strong><a name="filters" class="item">file - one or more filename filters (*.ext)</a></strong></dt>

<dt><strong><a name="text_constraints_on_text_fields_int_double_string" class="item">text - constraints on text fields: int|double|string</a></strong></dt>

<dt><strong><a name="mandatory_perltruthy_is_this_field_mandatory" class="item">mandatory - Perltruthy, is this field mandatory</a></strong></dt>

<dt><strong><a name="range_constrain_numeric_values" class="item">range - constrain numeric values</a></strong></dt>

<dt><strong><a name="inclusions_make_other_fields_mandatory_based_on_values_in_this_field" class="item">inclusions - make other fields mandatory based on values in this field</a></strong></dt>

<dt><strong><a name="exclusions_make_other_fields_forbidden_based_on_values_in_this_field" class="item">exclusions - make other fields forbidden based on values in this field</a></strong></dt>

</dl>
</dd>
<dt><strong><a name="parse" class="item"><code>parse()</code></a></strong></dt>

<dd>
<p>Parses the XML file.  On success, returns the entire form API as a hashref
with the following members:</p>
<dl>
<dt><strong><a name="groups_arrayref_of_parameter_groups" class="item">groups - arrayref of parameter groups</a></strong></dt>

<dt><strong><a name="files_hashref_of_file_fields" class="item">files - hashref of file fields</a></strong></dt>

<dt><strong><a name="guards_hashref_of_parameter_guards" class="item">guards - hashref of parameter guards</a></strong></dt>

</dl>
<p>The hashref is also stored internally as {api}.</p>
</dd>
<dt><strong><a name="xml_field" class="item"><code>xml_field($elt)</code></a></strong></dt>

<dd>
<p>Copy an element's inner_xml into the api using its tagname as
the field name</p>
</dd>
<dt><strong><a name="xml_category" class="item"><code>xml_category($elt)</code></a></strong></dt>

<dd>
<p>Parses the &lt;category&gt; element</p>
</dd>
<dt><strong><a name="xml_group" class="item"><code>xml_group($elt)</code></a></strong></dt>

<dd>
<p>Parses a &lt;group&gt; element.  Each app has a &lt;groups&gt; element,
containing one or more &lt;group&gt;s, each of which has one or more
&lt;parameters&gt;.  This routine calls xml_parameter on each of the
child parameters, stores it in a group hashref, then appends
the group hashref to {groups}</p>
</dd>
<dt><strong><a name="xml_parameter" class="item"><code>xml_parameter($elt)</code></a></strong></dt>

<dd>
<p>Top-level method for parsing parameters - the more complicated
child elements are farmed out to their own methods.</p>
<p>NOTE: in the ISIS schema, the tags default, greaterThan,
lessThan and notEqual contain one or more &lt;item&gt; tags, within
which are the actual values.  In the current release, there are
no apps which have more than one &lt;item&gt; tag in any of these 
elements, so this code just grabs the first item.</p>
</dd>
<dt><strong><a name="xml_minimax" class="item"><code>xml_minimax($elt)</code></a></strong></dt>

<dd>
<p>Parse a &lt;minimum&gt; or &lt;maximum&gt; element</p>
</dd>
<dt><strong><a name="xml_list" class="item"><code>xml_list($elt)</code></a></strong></dt>

<dd>
<p>Parse a &lt;list&gt; element, which gives a list with options and other
fiddle</p>
</dd>
<dt><strong><a name="xml_helpers" class="item"><code>xml_helpers($elt)</code></a></strong></dt>

<dd>
<p>Parse a &lt;helpers&gt; element, which holds 1+ helper functions</p>
</dd>
<dt><strong><a name="make_guard" class="item">make_guard(parameter =&gt; $p)</a></strong></dt>

<dd>
<p>Takes one of the parameter hashes from the API and returns the guards
for this as a Perl data structure.</p>
<p>To fetch an app's guards as a hash by parameter, call $app-&gt;<a href="#guards"><code>guards()</code></a>.</p>
<p>Conversion to JSON used to be done here but now it's left to the
Dancer framework</p>
</dd>
<dt><strong><a name="_make_input_filter_re" class="item">_make_input_filter_re(filter =&gt; '*.cub')</a></strong></dt>

<dd>
<p>Turns the content of a &lt;filter&gt; tag in the XML API and converts it
to a Javascript regexp, for eg:</p>
<pre>
    *.cub *.QUB

</pre>
<pre>
    \.(cub|QUB)$

</pre>
</dd>
<dt><strong><a name="_split_extensions_filter" class="item">_split_extensions_filter</a></strong></dt>

<dd>
<p>Splits a filter value like &quot;*.cub *.qub&quot; and returns an arrayref normalised
for case (so *.txt and *.TXT get merged)</p>
</dd>
<dt><strong><a name="_filter_to_exts" class="item">_filter_to_exts(filter =&gt; $filter)</a></strong></dt>

<dd>
<p>Takes a filter value like '*.txt *.TXT *.prt' and returns a case-normalised
array of extensions like [ 'prt', 'txt' ]</p>
</dd>
</dl>

</body>

</html>
